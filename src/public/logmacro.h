/*===========================================================================
     _____        _____        _____        _____
 ___|    _|__  __|_    |__  __|__   |__  __| __  |__  ______
|    \  /  | ||    \      ||     |     ||  |/ /     ||___   |
|     \/   | ||     \     ||     \     ||     \     ||___   |
|__/\__/|__|_||__|\__\  __||__|\__\  __||__|\__\  __||______|
    |_____|      |_____|      |_____|      |_____|

--[Mark3 Realtime Platform]--------------------------------------------------

Copyright (c) 2019 m0slevin, all rights reserved.
See license.txt for more information
=========================================================================== */
/*!
 @file logmacro.h  Debug logging macros

 This library provides a token-based logging mechanism, which is a highly-efficient
 alternative to printf-style logging with many benefits for embedded systems:

 - Efficiency and Determinism:
 -- There's no format string to process, and no arguments to convert into
    human-readible format at runtime.
 -- Cost of logging is reduced to copying header metadata and argument data
    in binary form into
 -- Even in the worst-case scenario, it's several times faster than using printf().
 -- Save on code size vs. printf, lack of format strings can also save code space

 - Fixed cost for format strings:
 -- No matter how long your format strings are, the cost to log them on the target is the same

 - Secure
 -- hash-based metadata is logged instead of a format string, limiting usefulness of
 logs to a potential hacker

 Using a combination of C++11, macro, and elf magic, this header provides a
 highly-efficient and easy-to-use token based logging alternative to printf.

 While printf is a convenient mechanism for embedded targets, it is often unadvisable
 to use it in a production real-time system due to the computationally intensive
 and non-deterministic format-string parsing operations involved.  These could
 potentially result in undesireable timing side effects that negatively impact
 the operation of the target device.  Furthermore, printf may not be thread-safe or
 interrupt safe depending on the underlying standard library implementation.

 The key to the optimized performance is the reliance on the preprocessor, compiler,
 and host-side tools to do most of the work, allowing the target to spend as few of
 its resources as possible in generating logs.

 When a user invokes the DEBUG_LOG() macro, the associated format string and file/line
 metadata is compiled to a special section of the elf file called ".logger" at build time.
 This is a non-executable section that does not add code or data size to the executable
 binary.  At runtime, the format string isn't logged by the target - only the file/line
 metadata is logged, along with any arguments in their native binary format.

 External host-side tools are then responsible for doing the work to post-process
 data coming from the target.  These tools also handle parsing of the .logger data
 extracted from the exectuable .elf file, building the file/line/format-string database,
 reading incoming data streams from the target, and finally generating human-readible
 output.

 To make use of this funcationality, a user only needs to make use of two macros provided
 in the header, as follows:

 1) Add EMIT_DBG_HEADER() after the #include block in any file that uses logging
 2) Use DEBUG_LOG() to invoke the logger with a printf-style format string, and
    tag arguments with the appropriate `Tag` formats.

 @code

    DEBUG_LOG("Testing2 %d %x\n", TagUint8, 1, TagUint32, 0x12345678);

 @endcode

 */
#pragma once

#include "mark3.h"
#include "logbuf.h"
#include "fnv_hash32.h"

//---------------------------------------------------------------------------
// Macro to generate a hash for a given source file.  Note:  This implementation
// applies to C++11 and onward.
#define HASH(string) hash_32_fnv1a_const( # string )
#define FILE_HASH   HASH(__FILENAME__)

//---------------------------------------------------------------------------
// ELF-file magic:  Emit the user's printf-style format string and file ID/line into
// a special elf section named ".logger".  The resulting output isn't part of the
// running code, but can be extracted by a separate debug-bridge service to 
// translate the binary logs generated by the application into human readable text
// with post-processing.  This allows the application to perform optimized,
// fixed-time logging operations (i.e. avoids runtime parsing of format strings)
// as part of the DEBUG_LOG() macros.
#define EMIT_DBG_STRING(str)                                                                                             \
    do {                                                                                                                 \
        const static volatile uint16_t __sync_begin __attribute__((section(".logger"))) __attribute__((used)) = 0xCAFE;   \
        const static volatile char     __log_str[] __attribute__((section(".logger"))) __attribute__((used))  = str;      \
        const static volatile uint16_t __line_id __attribute__((section(".logger"))) __attribute__((used))    = __LINE__; \
        const static volatile uint32_t __file_id __attribute__((section(".logger"))) __attribute__((used))    = FILE_HASH;  \
        const static volatile uint16_t __sync_end __attribute__((section(".logger"))) __attribute__((used)) = 0xD00D;   \
    } while (0);

//---------------------------------------------------------------------------
// More ELF-file magic: This code creates file-level debug information in the
// ".logger" elf file section.  A series of variable declarations are made
// that result in the filename and its unique hash being emitted, which can 
// be used to build a lookup table that maps a file to its hash, which is used
// to identify log components in post-processing.
#define EMIT_DBG_HEADER() \
        const static volatile uint16_t __file_sync_start __attribute__((section(".logger"))) __attribute__((used)) = 0xACDC;   \
        const static volatile uint32_t __file_id __attribute__((section(".logger"))) __attribute__((used))   = FILE_HASH;  \
        const static volatile char     __file_name[] __attribute__((section(".logger"))) __attribute__((used))   = __FILE__;      \
        const static volatile uint16_t __file_sync_end __attribute__((section(".logger"))) __attribute__((used)) = 0xABBA;   \

//---------------------------------------------------------------------------
// Preprocessor magic: This code creates a symbol name composed of "serialize_"
// concatenated with a user-provided symbol.  This is used to create function
// names based off of other existing symbols or identifiers.
// i.e., SERIALIZE(tag_char)(x) -> serialize_tag_char(x)

//---------------------------------------------------------------------------
#define SIZE_I(a) (uint8_t)SizeTag::Log##a
#define SIZE(a) SIZE_I(a)

//---------------------------------------------------------------------------
#define TAG_I(a) LogTag::Log##a
#define TAG(a) TAG_I(a)

//---------------------------------------------------------------------------
#define VALUE_I(a) v_##a
#define VALUE(a) VALUE_I(a)

//---------------------------------------------------------------------------
// Logging macros -- when a user calls DEBUG_LOG(), one of the following macros
// will be substituted, based on the number of arguments in the list.
#define _DEBUG_LOG5(s, fmt1, a1, fmt2, a2, fmt3, a3, fmt4, a4, fmt5, a5) \
do { \
	EMIT_DBG_STRING(s); \
    Tlv_t data[5] = { \
        {.tag = (unsigned int)TAG(fmt1), .length = SIZE(fmt1), .value = {.VALUE(fmt1) = a1}}, \
        {.tag = (unsigned int)TAG(fmt2), .length = SIZE(fmt2), .value = {.VALUE(fmt2) = a2}}, \
        {.tag = (unsigned int)TAG(fmt3), .length = SIZE(fmt3), .value = {.VALUE(fmt3) = a3}}, \
        {.tag = (unsigned int)TAG(fmt4), .length = SIZE(fmt4), .value = {.VALUE(fmt4) = a4}}, \
        {.tag = (unsigned int)TAG(fmt5), .length = SIZE(fmt5), .value = {.VALUE(fmt5) = a5}}, \
    }; \
    LogHeader_t header = { \
        .file_id = FILE_HASH, \
        .timestamp = Kernel::GetTicks(), \
        .line = __LINE__, \
        .log_count = 5, \
    }; \
    int length = sizeof(header) \
                + (sizeof(uint8_t) * 5) \
                + SIZE(fmt1) + SIZE(fmt2) + SIZE(fmt3) + SIZE(fmt4) + SIZE(fmt5); \
    auto &logBuf = LogBuf::Instance(); \
    logBuf.WriteLog(length, &header, data); \
} while (0); 

//---------------------------------------------------------------------------
#define _DEBUG_LOG4(s, fmt1, a1, fmt2, a2, fmt3, a3, fmt4, a4) \
do { \
    EMIT_DBG_STRING(s); \
    Tlv_t data[4] = { \
        {.tag = (unsigned int)TAG(fmt1), .length = SIZE(fmt1), .value = {.VALUE(fmt1) = a1}}, \
        {.tag = (unsigned int)TAG(fmt2), .length = SIZE(fmt2), .value = {.VALUE(fmt2) = a2}}, \
        {.tag = (unsigned int)TAG(fmt3), .length = SIZE(fmt3), .value = {.VALUE(fmt3) = a3}}, \
        {.tag = (unsigned int)TAG(fmt4), .length = SIZE(fmt4), .value = {.VALUE(fmt4) = a4}}, \
    }; \
    LogHeader_t header = { \
        .file_id = FILE_HASH, \
        .timestamp = Kernel::GetTicks(), \
        .line = __LINE__, \
        .log_count = 4, \
    }; \
    int length = sizeof(header) \
                + (sizeof(uint8_t) * 4) \
                + SIZE(fmt1) + SIZE(fmt2) + SIZE(fmt3) + SIZE(fmt4); \
    auto &logBuf = LogBuf::Instance(); \
    logBuf.WriteLog(length, &header, data); \
} while (0);

//---------------------------------------------------------------------------
#define _DEBUG_LOG3(s, fmt1, a1, fmt2, a2, fmt3, a3) \
do { \
    EMIT_DBG_STRING(s); \
    Tlv_t data[3] = { \
        {.tag = (unsigned int)TAG(fmt1), .length = SIZE(fmt1), .value = {.VALUE(fmt1) = a1}}, \
        {.tag = (unsigned int)TAG(fmt2), .length = SIZE(fmt2), .value = {.VALUE(fmt2) = a2}}, \
        {.tag = (unsigned int)TAG(fmt3), .length = SIZE(fmt3), .value = {.VALUE(fmt3) = a3}}, \
    }; \
    LogHeader_t header = { \
        .file_id = FILE_HASH, \
        .timestamp = Kernel::GetTicks(), \
        .line = __LINE__, \
        .log_count = 3, \
    }; \
    int length = sizeof(header) \
                + (sizeof(uint8_t) * 3) \
                + SIZE(fmt1) + SIZE(fmt2) + SIZE(fmt3); \
    auto &logBuf = LogBuf::Instance(); \
    logBuf.WriteLog(length, &header, data); \
} while(0);

//---------------------------------------------------------------------------
#define _DEBUG_LOG2(s, fmt1, a1, fmt2, a2) \
do { \
    EMIT_DBG_STRING(s); \
    Tlv_t data[2] = { \
        {.tag = (unsigned int)TAG(fmt1), .length = SIZE(fmt1), .value = {.VALUE(fmt1) = a1}}, \
        {.tag = (unsigned int)TAG(fmt2), .length = SIZE(fmt2), .value = {.VALUE(fmt2) = a2}}, \
    }; \
    LogHeader_t header = { \
        .file_id = FILE_HASH, \
        .timestamp = Kernel::GetTicks(), \
        .line = __LINE__, \
        .log_count = 2, \
    }; \
    int length = sizeof(header) \
                + (sizeof(uint8_t) * 2) \
                + SIZE(fmt1) + SIZE(fmt2); \
    auto &logBuf = LogBuf::Instance(); \
    logBuf.WriteLog(length, &header, data); \
} while (0);

//---------------------------------------------------------------------------
#define _DEBUG_LOG1(s, fmt1, a1) \
do { \
    EMIT_DBG_STRING(s); \
    Tlv_t data[1] = { \
        {.tag = (unsigned int)TAG(fmt1), .length = SIZE(fmt1), .value = {.VALUE(fmt1) = a1}}, \
    }; \
    LogHeader_t header = { \
        .file_id = FILE_HASH, \
        .timestamp = Kernel::GetTicks(), \
        .line = __LINE__, \
        .log_count = 1, \
    }; \
    int length = sizeof(header) \
                + sizeof(uint8_t) \
                + SIZE(fmt1); \
    auto &logBuf = LogBuf::Instance(); \
    logBuf.WriteLog(length, &header, data); \
} while (0);

//---------------------------------------------------------------------------
#define _DEBUG_LOG0(s) \
do { \
    EMIT_DBG_STRING(s); \
    LogHeader_t header = { \
        .file_id = FILE_HASH, \
        .timestamp = Kernel::GetTicks(), \
        .line = __LINE__, \
        .log_count = 0, \
    }; \
    int length = sizeof(header); \
    auto &logBuf = LogBuf::Instance(); \
    logBuf.WriteLog(length, &header, nullptr); \
} while (0);

//---------------------------------------------------------------------------
#define _LOG_ERROR \
	#error "Each argument requires a matching format tag"

//---------------------------------------------------------------------------
// Deep preprocessor magic:
// This uses a combination of a "slide rule" macro along with a variadic argument list
// to replace instances of a generic variadic macro for a concrete macro taking a fixed
// argument list.  
// A user can thus use a common macro like DEBUG_LOG(x, ...) for any number of arguments,
// and the preprocessor will automatically select the correct concrete macro (i.e. DEBUG_LOG0(x)
// or DEBUG_LOG1(x, a, b)) depending on the contents of the argument list.  This presents
// a huge boost in usability and maintainability, as users would otherwise have to manually 
// select a macro based on the number of arguments.
#define _GET_OVERRIDE(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, NAME, ...) NAME
#define DEBUG_LOG(x, ...) _GET_OVERRIDE("ignore", ##__VA_ARGS__, _LOG_ERROR, _DEBUG_LOG5, _LOG_ERROR, _DEBUG_LOG4, _LOG_ERROR, _DEBUG_LOG3, _LOG_ERROR, _DEBUG_LOG2, _LOG_ERROR, _DEBUG_LOG1, _LOG_ERROR, _DEBUG_LOG0)(x, ##__VA_ARGS__)


